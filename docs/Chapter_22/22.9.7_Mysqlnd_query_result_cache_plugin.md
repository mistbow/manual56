
### 22.9.7. Mysqlnd 查询结果缓存插件 ###
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright "Copyright 1997-2012 the PHP Documentation Group.")

对于所有使用[mysqlnd](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd.html "mysqlnd")的PHP MySQL扩展，Mysqlnd查询结果缓存插件都增加了客户端查询缓存的易用性。

对于PHP 5.3.3版本，PHP（mysqlnd）的MySQL原生驱动设有一个内部插件 C API. C插件，例如查询缓存插件，能够扩展mysqlnd新的功能。

Mysqlnd插件，如查询缓存插件，在用户的角度来说具有操作透明性。这个缓存插件支持所有的PHP应用程序，并支持所有的PHP MySQL扩展（mysqli，mysql，PDO\_MYSQL）。它并不改变现有的API。

缓存一个查询寻并不需要应用程序的大的改动。缓存有两种操作模式：一种是将所有的查询缓存（不推荐），另一种是只将标记特定SQL提示的查询缓存（推荐）。
#### 22.9.7.1. 主要特点 ####
- 透明性所以易于使用
 - 支持所有PHP MySQL扩展
 - 不改变API
 - 仅需要很少的应用程序的改变

- 灵活的失效策略
 - 生存时间 (TTL)
 - 用户定义
- 不同范围和不同寿命的存储
 - 默认值 (哈希, 进程内存)
 - APC
 - MEMCACHE
 - sqlite
 - 用户定义
 - 内置的的slam defense，以防止缓存蜂拥

#### 22.9.7.2. 限制 ####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

目前PECL mysqlnd_qc 1.0.1发行版本并不支持PHP 5.4。1.1.0-α版本取消了这个限制。

完全支持预处理语句和无缓冲查询。因此，该插件能够缓存所有mysqli或PDO_MySQL分配的语句，而它们是仅有的两个支持预处理语句的PHP MySQL API。
#### 22.9.7.3. 关于名称 ####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

该快捷的mysqlnd\_qc代表着mysqlnd查询缓存插件。选择这个名称是出于一种对quick-and-dirty概念的证明。起初，开发人员并没有想要去使用代码库。有时PECL/mysqlnd_qc也被称为客户端查询结果集缓存。
#### 22.9.7.4. 快速入门与实例 ####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

Mysqlnd查询缓存插件很易于使用。这里，快速入门将演示典型的使用实例，并且在开始之前提供一些使用的建议。

强烈建议阅读参考部分以便于快速入门。从快速入门开始练习是安全的。不过，在关键任务环境中使用插件之前，我们恳请您额外阅读参考部分的背景信息。

在大多数例子当中，都使用了[mysqli](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqli.html)扩展，因为它是功能最完整的PHP MySQL扩展。不过，这个插件可以与任何使用[mysqlnd](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd.html)库的MySQL扩展一同使用。
##### 22.9.7.4.1.架构和概念 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

查询缓存插件作为一个PHP扩展的实现，是用C编写而成，并在PHP的引擎下运行。在PHP解释器的启动过程中，它注册为一个[mysqlnd](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd.html)插件去替代选择的mysqlnd C方法。据此，对于任何没有改变API的被编译用来使用mysqlnd库的PHP MySQL扩展（[mysqli](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqli.html), [PDO_MYSQL](http://dev.mysql.com/doc/refman/5.6/en/apis-php-pdo-mysql.html), [mysql](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysql.html)），这个插件能够改变这些扩展的行为。这就使得这个插件能够与每一个PHP MySQL应用程序兼容，因为现有的API并没有变，所以使用起来几乎是透明的。请查阅[mysqlnd插件的API说明](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd.plugin.html)，讨论这个插件体系结构的优势并且与基于代理的解决方案进行比较。

*使用的透明性*

在PHP运行时，PECL/mysqlnd_qc能够代理从PHP（mysqlnd）发送到MySQL查询，随后检查语句字符串，以确定它时候需要缓存其结果。如果需要缓存结果，则结果集会用一个存储处理器缓存，接下来，在一个用户定义的阶段，将从缓存中提供语句的执行的服务。缓存的生存时间（TTL）条目或者是设置为全局的，或者是基于每个语句的。

对于一个语句来说，如果这个插件被指定全局性的缓存所有语句，或者查询语句以SQL提示（*/\*qc=on\*/*）开始，则它将被缓存。该插件能够缓存任何通过调用相应现有的PHP MySQL 扩展API的发出的查询。

*存储的灵活性：各种存储处理器*

很多存储处理器都被支持用来提供不同范围的缓存条目，不同的范围允许客户端之间共享缓存条目的不同程度。

- **默认**（内置）：进程内存，适用范围：进程，一个或多个使用PHP部署模型的web请求
- **APC**：共享内存，适用范围：单个服务器，多个web请求
- **SQLite**：内存或文件，适用范围：单个服务器，多个web请求
- **MEMCACHE**：主存，适用范围：单个或多个服务器，多个web请求
- **用户**（内置）：用户定义-其他，适用范围：用户定义-其他

支持APC、SQLite 和 MEMCACHE的存储处理器必须能够在编译时启用。默认的和用户处理器是内置的，它能够在内编译的存储处理器和一个在运行时基于单个查询的存储处理器之间进行切换，不过，建议选择一个存储处理器并且对于所有的缓存条目都使用它。

*内置的slam defense 避免超负载*

为避免超负荷的情况，缓存插件有一个内置的slam defense的机制。如果一个缓存条目过期了，许多使用缓存条目的用户将尝试刷新缓存条目。在刷新的期间，可能又有很多客户同时访问数据库服务器。最坏的情况，数据库服务器超负荷，它需要越来越多的时间去刷新缓存条目，这反过来又让更多的用户尝试刷新。为了防止这种情况的发生，插件有一个slam defense的机制。如果slam defense功能能够正常使用，插件会检测一个过期的缓存条目，然后在刷新这个条目之前，延长条目的生存时间。这样，其他对这个过期条目的并发的访问在一定时间内会仍然有效。其他的并发访问不会触发并发刷新，理想的情况下，缓存条目会被一些用户刷新，这些用户在其他用户尝试刷新并可能导致超负荷情况发生之前延长了缓冲条目的寿命。

*独有的缓存方法*

PECL/mysqlnd_qc有一个独特的方法来缓存结果集，这个方法优于基于应用程序的缓存方法。基于应用程序的的解决方案是，首先获取一个结果集到PHP变量中，然后，PHP变量会被序列化存储到一个持续缓存，随后在提取时反序列化。Mysqlnd查询缓存会存储从MySQL发送到PHP的原丝协议数据(the raw wire protocol data)到他的缓存中去，然后在一个缓存命中回放它（如果仍然有效的话）。这样，就节省了一个对于缓存的、额外的序列化步骤，而这个步骤是应用程序必须做的。另外，他能够在缓存中存储原始的有线协议数据，并且不需要将其序列化到PHP变量中而再次使用缓存。
##### 22.9.7.4.2. 安装 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

该插件作为一个PHP的扩展被实现，若要安装[PECL/mysqlnd_qc](http://pecl.php.net/package/mysqlnd_qc) 扩展，另请参考[安装说明](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.installation)。
编译或配置你打算的使用支持mysqlnd库的PHP MySQL扩展([mysqli](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqli.html), [PDO_MYSQL](http://dev.mysql.com/doc/refman/5.6/en/apis-php-pdo-mysql.html), [mysql](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysql.html))。PECL/mysqlnd_qc是一种支持mysqlnd库的插件，如果你想在任意现有的PHP MySQL扩展（APIs）上使用这个插件，那么这个扩展必须使用mysqlnd库。

接下来，加载这个扩展到PHP上，在PHP配置文件中，用 [mysqlnd_qc.enable_qc](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.enable-qc)这个配置指令激活插件。

**Example 22.307. 启用插件 (php.ini)**

```php
mysqlnd_qc.enable_qc=1
```

##### 22.9.7.4.3. 缓存查询 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

有四种方法出发一个查询的缓存动作。

- 基于每个查询使用SQL提示
- 基于每个查询用用户提供的回调函数来决定,，例如使用[mysqlnd_qc_is_select](http://www.php.net/mysqlnd_qc_is_select)
- [mysqlnd_set_cache_condition](http://www.php.net/mysqlnd_set_cache_condition) 对于每条查询自动根据规则来决定
- [mysqlnd_qc.cache_by_default = 1](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration) 缓存所有的查询

下面将解释SQL提示和[mysqlnd_qc.cache_by_default = 1](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration) 的使用。请参考两个函数说明：[mysqlnd_qc_is_select](http://www.php.net/mysqlnd_qc_is_select)使用一个回调函数的是说明；[mysqlnd_qc_set_cache_condition](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-cache-condition)如何针对自动缓存设置规则。

一个SQL提示是一个符合SQL标准的注释，因为一个SQL 注释是被数据库忽略的。一个语句，或者以SQL提示开头以允许缓存、或者它是一个SELECT语句，都是被认为可以缓存的。

一个独立查询，如果它应该被缓存，那么他必须以SQL提示 */\*qc=on\*/*开头。建议使用PHP常数[MYSQLND_QC_ENABLE_SWITCH](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.constants.html)，而不使用字符串值。

- 没有资格缓存且不缓存: INSERT INTO test(id) VALUES (1)
- 没有资格缓存且不缓存: SHOW ENGINES
- 有资格缓存但未缓存: SELECT id FROM test
- 有资格缓存且缓存: /*qc=on*/SELECT id FROM test

例子中，SELECT语句字符串前面加上了SQL提示：[MYSQLND_QC_ENABLE_SWITCH](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.constants.html)它允许缓存语句。若想启用缓存则，这条SQL提示必须附加在每条语句语句串的开头。

**Example 22.308. 使用 MYSQLND_QC_ENABLE_SWITCH SQL提示**

```php
mysqlnd_qc.enable_qc=1

    

<?php
/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* Will be cached because of the SQL hint */
$start = microtime(true);
$res   = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 1");

var_dump($res->fetch_assoc());
$res->free();

printf("Total time uncached query: %.6fs\n", microtime(true) - $start);

/* Cache hit */
$start = microtime(true);
$res   = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 1");

var_dump($res->fetch_assoc());
$res->free();

printf("Total time cached query: %.6fs\n", microtime(true) - $start);
?>
```
    
上面的例子将会得到类似下面的输出:

```php
array(1) {
  ["id"]=>
  string(1) "1"
}
Total time uncached query: 0.000740s
array(1) {
  ["id"]=>
  string(1) "1"
}
Total time cached query: 0.000098s
```

如果没有其他的配置，就像快速入门中的例子，该插件将会使用内置的默认存储处理器。这个默认的存储处理器使用进程内存来保存一个缓冲条目。根据PHP的部署模型，一个PHP进程可能会处理一个或多个web请求。详细信息请参考web server手册。详细信息与快速入门中给出的例子没有区别。

如果将PHP的设置指令[mysqlnd_qc.cache_by_default](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)设为1，那么无论在SQL提示开头中有没有允许缓存，缓冲查询插件会无条件缓存所有的查询。[mysqlnd_qc.cache_by_default](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)这个设置是查询缓存插件的核心来赋值的，无论是内置的存储处理器还是用户定义的存储处理器都不能影响该设置。

如果[mysqlnd_qc.cache_by_default = 1](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)，那么SQL提示*/\*qc=off\*/*可以禁用对单个查询的缓冲。建议使用PHP常量[MYSQLND_QC_DISABLE_SWITCH](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.constants.html)而不使用这个字符串值。

**Example 22.309.使用 MYSQLND_QC_DISABLE_SWITCH SQL 提示**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1

    

<?php
/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* Will be cached although no SQL hint is present because of mysqlnd_qc.cache_by_default = 1*/
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

$mysqli->query("DELETE FROM test WHERE id = 1");

/* Cache hit - no automatic invalidation and still valid! */
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* Cache miss - query must not be cached because of the SQL hint */
$res = $mysqli->query("/*" . MYSQLND_QC_DISABLE_SWITCH . "*/SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
?>
```

如上示例输出：

```
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "1"
}
NULL
```

PECL/mysqlnd\_qc禁止对语句的缓存，如果语句的结果中至少一列默认设置了在元数据中不现实表名。这种情况通常是使用如 NOW() 或LAST\_INSERT\_ID()函数。这个规则旨在避免因默认使用缓存引起的歧义。

**Example 22.310. Example showing which type of statements are not cached**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1

    

<?php
/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1)");

for ($i = 0; $i < 3; $i++) {

    $start = microtime(true);

    /* Note: statement will not be cached because of NOW() use */
    $res = $mysqli->query("SELECT id, NOW() AS _time FROM test");
    $row = $res->fetch_assoc();

    /* dump results */
    var_dump($row);

    printf("Total time: %.6fs\n", microtime(true) - $start);

    /* pause one second */
    sleep(1);
}
?>
```
  
类似如下输出：

```
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:10"
}
Total time: 0.000540s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:11"
}
Total time: 0.000555s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:43:12"
}
Total time: 0.000549s
```

可以缓存所有语句，包括那些在结果集中含有列，SQL报告中没有表。例如例子中的语句。设置[mysqlnd_qc.cache_no_table = 1](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.cache-no-table)，将允许缓存这样的语句。请注意上面的例子和下面的例子中，测量时间的差异。

**Example 22.311. Enabling caching for all statements using the mysqlnd_qc.cache_no_tableini setting**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.cache_by_default=1
mysqlnd_qc.cache_no_table=1


<?php
/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1)");

for ($i = 0; $i < 3; $i++) {

    $start = microtime(true);

    /* Note: statement will not be cached because of NOW() use */
    $res = $mysqli->query("SELECT id, NOW() AS _time FROM test");
    $row = $res->fetch_assoc();

    /* dump results */
    var_dump($row);

    printf("Total time: %.6fs\n", microtime(true) - $start);

    /* pause one second */
    sleep(1);
}
?>
```

将产生类似如下输出:

```
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Total time: 0.000546s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Total time: 0.000187s
array(2) {
  ["id"]=>
  string(1) "1"
  ["_time"]=>
  string(19) "2012-01-11 15:47:45"
}
Total time: 0.000167s
```

>**注意**
>
>虽然[mysqlnd_qc.cache_no_table = 1](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.cache-no-table)被创建出来与 [mysqlnd_qc.cache_by_default = 1](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)共同使用，不过也是必然的。无论何时一个查询被缓存时，该插件都会将[mysqlnd_qc.cache_no_table](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.cache-no-table)赋值，不管是否用SQL提示或是其他方法允许缓存。

##### 22.9.7.4.4. 设置 TTL #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

生存时间（TTL）是该查询缓存插件的默认的无效策略。内置的存储处理器会默认使用PHP设置值[mysqlnd_qc.ttl](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)设定的TTL，除非查询字符串中包含一个提示，或者设置了另一个不同的TTL。TTL的设置是以秒为单位。默认情况下，缓存条目将在30秒后到期。

下面这个例子设置mysqlnd\_qc.ttl=3，默认缓存语句3秒。每秒更新数据库表中的记录来保存当前的时间，并执行一个SELECT语句然后从数据库中获得记录。这个SELECT语句被缓存3秒，因为SQL提示允许了缓存。通过输出证明，该查询结果在被刷新之前的3秒中内从缓存中提取出来。

**Example 22.312. Setting the TTL with the mysqlnd_qc.ttl ini setting**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.ttl=3


<?php
/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id VARCHAR(255))");

for ($i = 0; $i < 7; $i++) {

    /* update DB row  */
    if (!$mysqli->query("DELETE FROM test") ||
        !$mysqli->query("INSERT INTO test(id) VALUES (NOW())"))
      /* Of course, a real-life script should do better error handling */
      die(sprintf("[%d] %s\n", $mysqli->errno, $mysqli->error));

    /* select latest row but cache results */
    $query  = "/*" . MYSQLND_QC_ENABLE_SWITCH . "*/";
    $query .= "SELECT id AS _time FROM test";
    if (!($res = $mysqli->query($query)) ||
        !($row = $res->fetch_assoc()))
    {
      printf("[%d] %s\n", $mysqli->errno, $mysqli->error);
    }
    $res->free();
    printf("Wall time %s - DB row time %s\n", date("H:i:s"), $row['_time']);

    /* pause one second */
    sleep(1);
}
?>
```
    
以上将得到类似如下输出:

```
Wall time 14:55:59 - DB row time 2012-01-11 14:55:59
Wall time 14:56:00 - DB row time 2012-01-11 14:55:59
Wall time 14:56:01 - DB row time 2012-01-11 14:55:59
Wall time 14:56:02 - DB row time 2012-01-11 14:56:02
Wall time 14:56:03 - DB row time 2012-01-11 14:56:02
Wall time 14:56:04 - DB row time 2012-01-11 14:56:02
Wall time 14:56:05 - DB row time 2012-01-11 14:56:05
```

从例子中可以看出，任何基于TTL的缓存可以成为过时的数据。如果底层数据变化，缓存条目不会自动失效，使用默认TTL失效策略的应用必须能够正常处理过时数据。
用户定义的缓存存储处理器，可以实现任何失效的策略，以解决这种限制。
使用SQL提示/*qc_tt=seconds*/可以覆盖默认的TTL。这个SQL提示必须在允许缓存的SQL提示后马上出现。建议使用PHP常量MYSQLND_QC_TTL_SWITCH而不是字符串值。

**Example 22.313. Setting TTL with SQL hints**

```php
<?php
$start = microtime(true);

/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

printf("Default TTL\t: %d seconds\n", ini_get("mysqlnd_qc.ttl"));

/* Will be cached for 2 seconds */
$sql = sprintf("/*%s*//*%s%d*/SELECT id FROM test WHERE id = 1", MYSQLND_QC_ENABLE_SWITCH, MYSQLND_QC_TTL_SWITCH, 2);
$res = $mysqli->query($sql);

var_dump($res->fetch_assoc());
$res->free();

$mysqli->query("DELETE FROM test WHERE id = 1");
sleep(1);

/* Cache hit - no automatic invalidation and still valid! */
$res = $mysqli->query($sql);
var_dump($res->fetch_assoc());
$res->free();

sleep(2);

/* Cache miss - cache entry has expired */
$res = $mysqli->query($sql);
var_dump($res->fetch_assoc());
$res->free();

printf("Script runtime\t: %d seconds\n", microtime(true) - $start);
?>
```
  
上面的例子将得到类似如下输出:

```
Default TTL     : 30 seconds
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "1"
}
NULL
Script runtime  : 3 seconds
```

##### 22.9.7.4.5. 基于模式的缓存 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

应用程序有三种方式告诉PECL/mysqlnd\_qc是否将使用一个特殊的语句，最基本的方式是设置 [mysqlnd_qc.cache_by_default = 1](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)，缓存所有的语句。这种方法往往没什么实际价值，但是它可以让用户对从缓存中的最大的性能增益迅速作出估算。一个被设计使用缓存的应用程序能够将带有适当的SQL提示附加到选择的语句前。然而，改变一个应用程序的源代码通常是不可能的也不需要这样做，例如，以避免软件更新的问题。因此，PECL/mysqlnd\_qc允许设置一个回调函数，通过这个回调函数来决定是否缓存一个查询。

回调是与[mysqlnd_qc_set_is_select](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-is-select)功能一同安装的。插件会检查每个语句，然后将每个语句字符串传到回调函数那里。接着，回调函数将决定是否缓存这个功能，如果语句不被缓存，回调函数应返回FALSE。如果返回值是TRUE，那么插件将尝试添加语句到缓存里。缓存条目将被给与默认的TTL([mysqlnd_qc.ttl](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration))。如果返回值是一个数值，那么这个数值将被用来作为TTL值，而不使用全局默认值。

**Example 22.314. Setting a callback with mysqlnd_qc_set_is_select**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_statistics=1


<?php
/* callback which decides if query is cached */
function is_select($query) {
    static $patterns = array(
      /* true - use default from mysqlnd_qc.ttl */
      "@SELECT\s+.*\s+FROM\s+test@ismU" => true,
      /* 3 - use TTL = 3 seconds */
      "@SELECT\s+.*\s+FROM\s+news@ismU" => 3
    );

    /* check if query does match pattern */
    foreach ($patterns as $pattern => $ttl) {
        if (preg_match($pattern, $query)) {
            printf("is_select(%45s): cache\n", $query);
            return $ttl;
        }
    }
    printf("is_select(%45s): do not cache\n", $query);
    return false;
}
/* install callback */
mysqlnd_qc_set_is_select("is_select");

/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* cache put */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* cache hit */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* cache put */
$mysqli->query("SELECT * FROM test");

$stats = mysqlnd_qc_get_core_stats();
printf("Cache put: %d\n", $stats['cache_put']);
printf("Cache hit: %d\n", $stats['cache_hit']);
?>
```
    
上面例子将得到类似如下输出:

```
is_select(                    DROP TABLE IF EXISTS test): do not cache
is_select(                    CREATE TABLE test(id INT)): do not cache
is_select(    INSERT INTO test(id) VALUES (1), (2), (3)): do not cache
is_select(             SELECT id FROM test WHERE id = 1): cache
is_select(             SELECT id FROM test WHERE id = 1): cache
is_select(                           SELECT * FROM test): cache
Cache put: 2
Cache hit: 1
```

上面的例子测试的是一个语句字符串是否匹配一种模式。如果是这样，它使用全局默认的TTL或者另一个可替代的TTL来缓存语句。

为了最大程度上减少应用程序的更改，回调函数可以放入并注册在一个自动的前置文件。

##### 22.9.7.4.6. Slam defense #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

一个缓存如果设计不好，那么将会是弊大于利。最坏情况下，缓存不仅对最小化数据库服务器的负载没有帮助反而会增加其负载。如果一个共享度的缓存条目过期（cache stampeding），那么过载的情况就会发生。

缓存条目会在不同程度上被共享和重用，这取决于存储器的使用情况。默认存储处理程序在进程内存中存储缓存条目。因此，缓存条目在一个进程的生命周期里是可重用的。其他的PHP进程是不能够访问它的。如果使用Memcache，一个缓存条目可以在多个PHP进程之间共享甚至在多台机器上，当然，这取决于你使用什么样的设置。

如果一个存储在Memcache共享度高的缓存条目到期，那么多数用户将有缓存失效（cache miss）的情况。多数用户的请求将不能从缓存中得到，而只能尝试运行数据库服务器的底层查询。越来越多的用户直接用到数据库服务器，直到缓存条目被刷新。最坏的情况是无法服务。
用存储处理器限制少量用户对缓存条目的复用，可以避免负载。然后，平均看来，就像是有限数量的客户端并发刷新缓存条目。

此外，内置的slam defense机制可以而且应该被使用。如果slam defense被激活，然后一个过期的缓存条目的生存时间被延长。对于一个过期的缓存条目，第一个遇到缓存失效（cache miss）的用户会尝试在这个延长的生存周期内刷新这个条目，其他查询这个条目的用户会暂时从缓存中得到服务，尽管条目原来的TTL已经到期。那么，在这个延长的生存周期结束之前，其他的用户就不会于导缓存失效（cache miss）的情况了。

**Example 22.315. Enabling the slam defense mechanism**

```php
mysqlnd_qc.slam_defense=1
mysqlnd_qc.slam_defense_ttl=1
```

PHP配置指令[mysqlnd_qc.slam_defense](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.slam-defense)激活slam defense 机制，[mysqlnd_qc.slam_defense_ttl](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.slam-defense-ttl)：延长缓存条目生存周期。

[mysqlnd_qc_get_core_stats](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-core-stats)函数将返回一系列的统计信息，如果slam defense发生了，统计量slam_stale_refresh和slam_stale_hit将会增加。

在slam defense的配置上，给出一个放之四海而皆准的建议几乎是不可能的，建议用户监视并测试他们的设置，进而得到更好的设置。

##### 22.9.7.4.7. 寻找缓存候选对象 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

如果一个语句经常被执行，或者运行时间很长，则应到考虑将其放入缓存。缓存候选对象是在一个语句的列表中查找到的，这个列表是将语句执行次数和运行时间的乘积为排序标准。[mysqlnd_qc_get_query_trace_log](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-query-trace-log)函数返回一个查询日志，这个日志可以帮助完成选择候选对象的任务。

收集查询跟踪query trace是一个缓慢的操作，因此，默认情况下是禁用的。可以用PHP配置指令[mysqlnd_qc.collect_query_trace](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-query-trace)激活。这个跟踪包含在跟踪功能调用前对一个条目发起的所有查询。

**Example 22.316. Collecting a query trace**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_query_trace=1


<?php
/* connect to MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");

/* dummy queries to fill the query trace */
for ($i = 0; $i < 2; $i++) {
    $res = $mysqli->query("SELECT 1 AS _one FROM DUAL");
    $res->free();
}

/* dump trace */
var_dump(mysqlnd_qc_get_query_trace_log());
?>
```
    
输出:

```
array(2) {
  [0]=>
  array(8) {
    ["query"]=>
    string(26) "SELECT 1 AS _one FROM DUAL"
    ["origin"]=>
    string(102) "#0 qc.php(7): mysqli->query('SELECT 1 AS _on...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(25)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [1]=>
  array(8) {
    ["query"]=>
    string(26) "SELECT 1 AS _one FROM DUAL"
    ["origin"]=>
    string(102) "#0 qc.php(7): mysqli->query('SELECT 1 AS _on...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(8)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
}
```

跟踪信息中还包含许多其他信息，其中有计时以及查询源。Origin属性持有一个用来识别查询源的代码回溯。使用PHP配置指令[mysqlnd_qc.query_trace_bt_depth](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.query-trace-bt-depth)可以限制回溯深度，默认深度为3.

**Example 22.317. Setting the backtrace depth with the mysqlnd_qc.query_trace_bt_depth ini setting**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_query_trace=1


<?php
/* connect to MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* dummy queries to fill the query trace */
for ($i = 0; $i < 3; $i++) {
    $res = $mysqli->query("SELECT id FROM test WHERE id = " . $mysqli->real_escape_string($i));
    $res->free();
}

$trace = mysqlnd_qc_get_query_trace_log();
$summary = array();
foreach ($trace as $entry) {
    if (!isset($summary[$entry['query']])) {
        $summary[$entry['query']] = array(
            "executions" => 1,
            "time"       => $entry['run_time'] + $entry['store_time'],
        );
    } else {
        $summary[$entry['query']]['executions']++;
        $summary[$entry['query']]['time'] += $entry['run_time'] + $entry['store_time'];
    }
}

foreach ($summary as $query => $details) {
    printf("%45s: %5dms (%dx)\n",
    $query, $details['time'], $details['executions']);
}
?>
```
    
上面的例子将得到类似如下输出:

```
                    DROP TABLE IF EXISTS test:     0ms (1x)
                    CREATE TABLE test(id INT):     0ms (1x)
    INSERT INTO test(id) VALUES (1), (2), (3):     0ms (1x)
             SELECT id FROM test WHERE id = 0:    25ms (1x)
             SELECT id FROM test WHERE id = 1:    10ms (1x)
             SELECT id FROM test WHERE id = 2:     9ms (1x)
```

##### 22.9.7.4.8.衡量缓存效率 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

PECL/mysqlnd_qc提供三种方法衡量缓存的效率。函数[mysqlnd_qc_get_normalized_query_trace_log](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-normalized-query-trace-log)返回规范化查询字符串的统计汇总，[mysqlnd_qc_get_cache_info](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-cache-info)给予存储处理器具体的信息，根据存储处理器包括一个缓存条目的清单。此外，PECL/mysqlnd\_qc的核心会收集每个PHP进程高度概括的统计汇总。这个高度概括的统计由[mysqlnd_qc_get_core_stats](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-core-stats)返回。
数[mysqlnd_qc_get_normalized_query_trace_log](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-normalized-query-trace-log)和[mysqlnd_qc_get_core_stats](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-core-stats)不会收集数据，除非数据采集已启用通过设置相应的PHP配置指令。出于性能方面的考虑，在默认情况下是禁用的数据收集的。它可以与[mysqlnd_qc.time_statistics](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.time-statistics)选项一同配置，来决定是否应该收集时序信息。时间信息的收集是默认启用的，但是只在数据收集被启用时才被执行。记录时间统计信息会调用额外的系统调用，大多数情况下，监控的好处超过额外系统调用产生的潜在的性能损失。

**Example 22.318. Collecting statistics data with the mysqlnd_qc.time_statistics ini setting**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_statistics=1


<?php
/* connect to MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* dummy queries */
for ($i = 1; $i <= 4; $i++) {
    $query = sprintf("/*%s*/SELECT id FROM test WHERE id = %d", MYSQLND_QC_ENABLE_SWITCH, $i % 2);
    $res   = $mysqli->query($query);
    
    $res->free();
}

var_dump(mysqlnd_qc_get_core_stats());
?>
```
    
上面的例子将得到类似如下的输出:

```
array(26) {
  ["cache_hit"]=>
  string(1) "2"
  ["cache_miss"]=>
  string(1) "2"
  ["cache_put"]=>
  string(1) "2"
  ["query_should_cache"]=>
  string(1) "4"
  ["query_should_not_cache"]=>
  string(1) "3"
  ["query_not_cached"]=>
  string(1) "3"
  ["query_could_cache"]=>
  string(1) "4"
  ["query_found_in_cache"]=>
  string(1) "2"
  ["query_uncached_other"]=>
  string(1) "0"
  ["query_uncached_no_table"]=>
  string(1) "0"
  ["query_uncached_no_result"]=>
  string(1) "0"
  ["query_uncached_use_result"]=>
  string(1) "0"
  ["query_aggr_run_time_cache_hit"]=>
  string(2) "28"
  ["query_aggr_run_time_cache_put"]=>
  string(3) "900"
  ["query_aggr_run_time_total"]=>
  string(3) "928"
  ["query_aggr_store_time_cache_hit"]=>
  string(2) "14"
  ["query_aggr_store_time_cache_put"]=>
  string(2) "40"
  ["query_aggr_store_time_total"]=>
  string(2) "54"
  ["receive_bytes_recorded"]=>
  string(3) "136"
  ["receive_bytes_replayed"]=>
  string(3) "136"
  ["send_bytes_recorded"]=>
  string(2) "84"
  ["send_bytes_replayed"]=>
  string(2) "84"
  ["slam_stale_refresh"]=>
  string(1) "0"
  ["slam_stale_hit"]=>
  string(1) "0"
  ["request_counter"]=>
  int(1)
  ["process_hash"]=>
  int(1929695233)
}
```

做一个小结，调用[mysqlnd_qc_get_core_stats](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-core-stats)，提供缓存的使用，以及时间和流量相关的统计数据。数据的汇总是基于进程的，而且面向任何PHP MYSQL API调用而发起的所有查询。
有一些存储处理器，比如默认的处理器，通过函数[mysqlnd_qc_get_cache_info](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-cache-info)，可以汇报缓存条目，条目以及基础查询元数据相关的统计信息。请注意，返回的信息依赖于存储处理器，数据的汇总是基于每个进程的。

**Example 22.319. Example mysqlnd_qc_get_cache_info usage**

```php
mysqlnd_qc.enable_qc=1


<?php
/* connect to MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* dummy queries to fill the query trace */
for ($i = 1; $i <= 4; $i++) {
    $query = sprintf("/*%s*/SELECT id FROM test WHERE id = %d", MYSQLND_QC_ENABLE_SWITCH, $i % 2);
    $res   = $mysqli->query($query);
  
    $res->free();
}

var_dump(mysqlnd_qc_get_cache_info());
?>
```
    
上面的例子将得到类似如下输出:

```
array(4) {
  ["num_entries"]=>
  int(2)
  ["handler"]=>
  string(7) "default"
  ["handler_version"]=>
  string(5) "1.0.0"
  ["data"]=>
  array(2) {
    ["Localhost via UNIX socket
3306
root
test|/*qc=on*/SELECT id FROM test WHERE id = 1"]=>
    array(2) {
      ["statistics"]=>
      array(11) {
        ["rows"]=>
        int(1)
        ["stored_size"]=>
        int(71)
        ["cache_hits"]=>
        int(1)
        ["run_time"]=>
        int(391)
        ["store_time"]=>
        int(27)
        ["min_run_time"]=>
        int(16)
        ["max_run_time"]=>
        int(16)
        ["min_store_time"]=>
        int(8)
        ["max_store_time"]=>
        int(8)
        ["avg_run_time"]=>
        int(8)
        ["avg_store_time"]=>
        int(4)
      }
      ["metadata"]=>
      array(1) {
        [0]=>
        array(8) {
          ["name"]=>
          string(2) "id"
          ["orig_name"]=>
          string(2) "id"
          ["table"]=>
          string(4) "test"
          ["orig_table"]=>
          string(4) "test"
          ["db"]=>
          string(4) "test"
          ["max_length"]=>
          int(1)
          ["length"]=>
          int(11)
          ["type"]=>
          int(3)
        }
      }
    }
    ["Localhost via UNIX socket
3306
root
test|/*qc=on*/SELECT id FROM test WHERE id = 0"]=>
    array(2) {
      ["statistics"]=>
      array(11) {
        ["rows"]=>
        int(0)
        ["stored_size"]=>
        int(65)
        ["cache_hits"]=>
        int(1)
        ["run_time"]=>
        int(299)
        ["store_time"]=>
        int(13)
        ["min_run_time"]=>
        int(11)
        ["max_run_time"]=>
        int(11)
        ["min_store_time"]=>
        int(6)
        ["max_store_time"]=>
        int(6)
        ["avg_run_time"]=>
        int(5)
        ["avg_store_time"]=>
        int(3)
      }
      ["metadata"]=>
      array(1) {
        [0]=>
        array(8) {
          ["name"]=>
          string(2) "id"
          ["orig_name"]=>
          string(2) "id"
          ["table"]=>
          string(4) "test"
          ["orig_table"]=>
          string(4) "test"
          ["db"]=>
          string(4) "test"
          ["max_length"]=>
          int(0)
          ["length"]=>
          int(11)
          ["type"]=>
          int(3)
        }
      }
    }
  }
}
```

根据标准化语句字符串的级别，是可以进一步分解统计数据的粒度的，标准化语句字符串是所有的语句字符串的参数都用问号替代。例如，`SELECT id FROM test WHERE id = 0 `和`SELECT id FROM test WHERE id = 1`两个语句，会标准化为`SELECT id FROM test WHERE id = ?`。关于这两个统计数据都会被汇总到`SELECT id FROM test WHERE id = ?`一个条目上。

**Example 22.320. Example mysqlnd_qc_get_normalized_query_trace_log usage**

```php
mysqlnd_qc.enable_qc=1
mysqlnd_qc.collect_normalized_query_trace=1


<?php
/* connect to MySQL */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* dummy queries to fill the query trace */
for ($i = 1; $i <= 4; $i++) {
    $query = sprintf("/*%s*/SELECT id FROM test WHERE id = %d", MYSQLND_QC_ENABLE_SWITCH, $i % 2);
    $res   = $mysqli->query($query);
  
    $res->free();
}

var_dump(mysqlnd_qc_get_normalized_query_trace_log());
?>
```
  
上面的例子将得到类似如下输出:

```
array(4) {
  [0]=>
  array(9) {
    ["query"]=>
    string(25) "DROP TABLE IF EXISTS test"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [1]=>
  array(9) {
    ["query"]=>
    string(27) "CREATE TABLE test (id INT )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [2]=>
  array(9) {
    ["query"]=>
    string(46) "INSERT INTO test (id ) VALUES (? ), (? ), (? )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [3]=>
  array(9) {
    ["query"]=>
    string(31) "SELECT id FROM test WHERE id =?"
    ["occurences"]=>
    int(4)
    ["eligible_for_caching"]=>
    bool(true)
    ["avg_run_time"]=>
    int(179)
    ["min_run_time"]=>
    int(11)
    ["max_run_time"]=>
    int(393)
    ["avg_store_time"]=>
    int(12)
    ["min_store_time"]=>
    int(7)
    ["max_store_time"]=>
    int(25)
  }
}
```

The source distribution of PECL/mysqlnd_qc contains a directory web/ in which web based monitoring scripts can be found which give an example how to write a cache monitor. Please, follow the instructions given in the source
PECL/mysqlnd_qc 1.1.0可以将统计信息写入一个日志文件里，请查看[mysqlnd_qc.collect_statistics_log_file](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-statistics-log-file)。

##### 22.9.7.4.9. Beyond TTL: user-defined storage #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

查询缓存插件支持用户的存储处理器的使用，用户定义的存储处理器可以使用任意复杂的失效算法并且支持任意的存储介质。

所有用户定义的存储处理器提供了一定的接口。用户定义的存储处理器的函数将通过插件的核心进行调用，必要的接口包括的七个公共函数。不管是面向过程还是面向对象的用户定义的存储处理器，都必须实现相同的功能集。

**Example 22.321. Using a user-defined storage handler**

```php
<?php
/* Enable default caching of all statements */
ini_set("mysqlnd_qc.cache_by_default", 1);

/* Procedural user defined storage handler functions */

$__cache = array();

function get_hash($host_info, $port, $user, $db, $query) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    return md5(sprintf("%s%s%s%s%s", $host_info, $port, $user, $db, $query));
}

function find_query_in_cache($key) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    if (isset($__cache[$key])) {
        $tmp = $__cache[$key];
        if ($tmp["valid_until"] < time()) {
            unset($__cache[$key]);
            $ret = NULL;
        } else {
            $ret = $__cache[$key]["data"];
        }
    } else {
        $ret = NULL;
    }

    return $ret;
}

function return_to_cache($key) {
    /*
     Called on cache hit after cached data has been processed,
     may be used for reference counting
    */
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());
}

function add_query_to_cache_if_not_exists($key, $data, $ttl, $run_time, $store_time, $row_count) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    $__cache[$key] = array(
        "data"               => $data,
        "row_count"          => $row_count,
        "valid_until"        => time() + $ttl,
        "hits"               => 0,
        "run_time"           => $run_time,
        "store_time"         => $store_time,
        "cached_run_times"   => array(),
        "cached_store_times" => array(),
    );

    return TRUE;
}

function query_is_select($query) {
    printf("\t%s('%s'): ", __FUNCTION__, $query);

    $ret = FALSE;
    if (stristr($query, "SELECT") !== FALSE) {
        /* cache for 5 seconds */
        $ret = 5;
    }

    printf("%s\n", (FALSE === $ret) ? "FALSE" : $ret);
    return $ret;
}

function update_query_run_time_stats($key, $run_time, $store_time) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    if (isset($__cache[$key])) {
        $__cache[$key]['hits']++;
        $__cache[$key]["cached_run_times"][] = $run_time;
        $__cache[$key]["cached_store_times"][] = $store_time;
    }
}

function get_stats($key = NULL) {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    if ($key && isset($__cache[$key])) {
        $stats = $__cache[$key];
    } else {
        $stats = array();
        foreach ($__cache as $key => $details) {
            $stats[$key] = array(
               'hits'              => $details['hits'],
               'bytes'             => strlen($details['data']),
               'uncached_run_time' => $details['run_time'],
               'cached_run_time'   => (count($details['cached_run_times']))
                                      ? array_sum($details['cached_run_times']) / count($details['cached_run_times'])
                                      : 0,
            );
        }
    }

    return $stats;
}

function clear_cache() {
    global $__cache;
    printf("\t%s(%d)\n", __FUNCTION__, func_num_args());

    $__cache = array();
    return TRUE;
}

/* Install procedural user-defined storage handler */
if (!mysqlnd_qc_set_user_handlers("get_hash", "find_query_in_cache",
    "return_to_cache", "add_query_to_cache_if_not_exists",
    "query_is_select", "update_query_run_time_stats", "get_stats", "clear_cache")) {
  
        printf("Failed to install user-defined storage handler\n");
}


/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

printf("\nCache put/cache miss\n");

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* Delete record to verify we get our data from the cache */
$mysqli->query("DELETE FROM test WHERE id = 1");

printf("\nCache hit\n");

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

printf("\nDisplay cache statistics\n");
var_dump(mysqlnd_qc_get_cache_info());

printf("\nFlushing cache, cache put/cache miss");
var_dump(mysqlnd_qc_clear_cache());

$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();
?>
```
    
以上示例将会输出如下:

```
        query_is_select('DROP TABLE IF EXISTS test'): FALSE
        query_is_select('CREATE TABLE test(id INT)'): FALSE
        query_is_select('INSERT INTO test(id) VALUES (1), (2)'): FALSE

Cache put/cache miss
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        add_query_to_cache_if_not_exists(6)
array(1) {
  ["id"]=>
  string(1) "1"
}
        query_is_select('DELETE FROM test WHERE id = 1'): FALSE

Cache hit
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        return_to_cache(1)
        update_query_run_time_stats(3)
array(1) {
  ["id"]=>
  string(1) "1"
}

Display cache statistics
        get_stats(0)
array(4) {
  ["num_entries"]=>
  int(1)
  ["handler"]=>
  string(4) "user"
  ["handler_version"]=>
  string(5) "1.0.0"
  ["data"]=>
  array(1) {
    ["18683c177dc89bb352b29965d112fdaa"]=>
    array(4) {
      ["hits"]=>
      int(1)
      ["bytes"]=>
      int(71)
      ["uncached_run_time"]=>
      int(398)
      ["cached_run_time"]=>
      int(4)
    }
  }
}

Flushing cache, cache put/cache miss    clear_cache(0)
bool(true)
        query_is_select('SELECT id FROM test WHERE id = 1'): 5
        get_hash(5)
        find_query_in_cache(1)
        add_query_to_cache_if_not_exists(6)
NULL
```

#### 22.9.7.5. 安装/配置 ####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

##### 22.9.7.5.1. 安装条件 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

`PHP 5.3.3` 或更新版本的php。

PECL/mysqlnd\_qc是一个mysqlnd插件，它被安置在mysqlnd库中，若要将这个插件连同一个PHP MySQL扩展使用，那么扩展([mysqli](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqli.html), [mysql](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysql.html), 或者[PDO\_MYSQL](http://dev.mysql.com/doc/refman/5.6/en/apis-php-pdo-mysql.html))必须启用mysqlnd库。
对于使用带有PECL/mysqlnd\_qc 1.0`APC 3.1.3p1-beta`或更高版本的APC存储处理器， PECL/mysqlnd\_qc 1.2已经过`APC 3.1.13-beta`测试，该APC存储处理器不能使用共享构建。如果PECL/mysqlnd\_qc要使用APC作为存储处理器，你不能使用PHP配置指令扩展去加载一个APC和PECL/mysqlnd\_qc扩展。如果你要使用APC存储处理器，那你必须静态编译PHP和APC，然后将PECL/mysqlnd\_qc支持到PHP。
如果使用`MEMCACHE`存储处理器，请使用`libmemcache 0.38`或更高版本，PECL/mysqlnd\_qc 1.2已经过`libmemcache 1.4.0`测试。
如果使用`sqlite`存储处理器，请使用捆绑在PHP上的[sqlite3](http://www.php.net/book.sqlite3)扩展。
##### 22.9.7.5.2. 安装 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

[PECL](http://pecl.php.net/)扩展没有与PHP绑定。
安装此PECL扩展的详细信息可以参考手册上名为[安装PECL扩展](http://www.php.net/install.pecl)的章节。额外的信息比如新版本、下载、源文件、维护者信息以及CHANGELOG可以在这里找到:[http://pecl.php.net/package/mysqlnd_qc](http://pecl.php.net/package/mysqlnd_qc)。
这个PECL扩展的DLL当前不可用。另请参阅[building on Windows](http://www.php.net/install.windows.building)章节。
##### 22.9.7.5.3. 运行时配置 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

这些函数的行为受`php.ini`中的配置影响.
**Table 22.78. mysqlnd_qc 配置选项**

<table summary="mysqlnd_qc Configure Options" border="1" class="table table-bordered table-striped table-condensed" style="border-collapse: collapse">
  <thead>
    <tr>
      <th scope="col">名称</th>
      <th scope="col">默认值</th>
      <th scope="col">可变值</th>
      <th scope="col">变更日志</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.enable-qc">mysqlnd_qc.enable_qc</a></td>
      <td>1</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.ttl">mysqlnd_qc.ttl</a></td>
      <td>30</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.cache-by-default">mysqlnd_qc.cache_by_default</a></td>
      <td>0</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.cache-no-table">mysqlnd_qc.cache_no_table</a></td>
      <td>0</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.use-request-time">mysqlnd_qc.use_request_time</a></td>
      <td>0</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.time-statistics">mysqlnd_qc.time_statistics</a></td>
      <td>1</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-statistics">mysqlnd_qc.collect_statistics</a></td>
      <td>0</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-statistics-log-file">mysqlnd_qc.collect_statistics_log_file</a></td>
      <td>/tmp/mysqlnd_qc.stats</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-query-trace">mysqlnd_qc.collect_query_trace</a></td>
      <td>0</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.query-trace-bt-depth">mysqlnd_qc.query_trace_bt_depth</a></td>
      <td>3</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-normalized-query-trace">mysqlnd_qc.collect_normalized_query_trace</a></td>
      <td>0</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.ignore-sql-comments">mysqlnd_qc.ignore_sql_comments</a></td>
      <td>1</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.slam-defense">mysqlnd_qc.slam_defense</a></td>
      <td>0</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.slam-defense-ttl">mysqlnd_qc.slam_defense_ttl</a></td>
      <td>30</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.std-data-copy">mysqlnd_qc.std_data_copy</a></td>
      <td>0</td>
      <td>PHP_INI_SYSTEM</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.apc-prefix">mysqlnd_qc.apc_prefix</a></td>
      <td>qc_</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.memc-server">mysqlnd_qc.memc_server</a></td>
      <td>127.0.0.1</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.memc-port">mysqlnd_qc.memc_port</a></td>
      <td>11211</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td scope="row"><a class="link" href="apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.sqlite-data-file">mysqlnd_qc.sqlite_data_file</a></td>
      <td>:memory:</td>
      <td>PHP_INI_ALL</td>
      <td>&nbsp;</td>
    </tr>
  </tbody>
</table>
	 
一下是配置指令的简短说明

*`mysqlnd_qc.enable_qc`* 整形
>启用或禁用插件。如果禁用插件，扩展将不会插入到[mysqlnd](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd.html)去代理内部的[mysqlnd](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd.html)C API 调用。

*`mysqlnd_qc.ttl`* 整形
>缓存条目的默认生存周期（TTL），单位为秒。

*`mysqlnd_qc.cache_by_default`* 整形
>无条件缓存所有查询，无论是否有SQL提示允许缓存一个查询。存储处理器不能影响设置，是由该插件的核心来评估。

*`mysqlnd_qc.cache_no_table`* 整形
>是否缓存任何列结果集的元数据没有表名的查询, 例如,`SELECT SLEEP(1)`, `SELECT NOW()`, `SELECT SUBSTRING()`。

mysqlnd_qc.use_request_time 整形
>使用PHP全局请求时间以避免`gettimeofday()`系统调用？如果使用[APC](http://www.php.net/ref.apc)存储处理器，那么如果不会生成警告，则必须设置[apc.use_request_time](http://www.php.net/apc.configuration)的值。

*`mysqlnd_qc.time_statistics`* 整形
>使用`gettimeofday()`系统调用收集运行时间以及存储时间的统计信息？只有设置`mysqlnd_qc.collect_statistics = 1`, 数据才将被收集。

*`mysqlnd_qc.collect_statistics`* 整形
>[mysqlnd_qc_get_core_stats](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-core-stats)收集统计信息？不要影响存储处理器的统计信息!处理器的统计信息是内部存储格式的处理器的一个不可分割的部分. 因此一些处理器的统计信息不可以禁用。

*`mysqlnd_qc.collect_statistics-log-file`* 整形
>如果设置了`mysqlnd_qc.collect_statistics`和`mysqlnd_qc.collect_statistics_log_file`, 插件会在PHP请求关闭前，以每10个web请求为单位，将统计信息转储到特定的日志文件中。日志文件需要对web server用户有可写权限。
>
>自1.1.0后

*`mysqlnd_qc.collect_query_trace`* 整形
>收集查询跟踪?

*`mysqlnd_qc.query_trace_bt_depth`* 整形
>一个查询代码回溯的最大深度。

*`mysqlnd_qc.ignore_sql_comments`* 整形
>在散列一个查询字符串的SQL命令得到一个缓存键之前，是否将其删除？如果你不想将两个语句散列到一个缓存条目里，例如`SELECT /*my_source_ip=123*/ id FROM test`和`SELECT /*my_source_ip=456*/ id FROM test`，那么禁用它。
>
>自1.1.0后

*`mysqlnd_qc.slam_defense`* 整形
>可行的话，激活基于处理器的slam defense（缓存逃逸保护）`默认`的以及[APC](http://www.php.net/ref.apc)存储处理器都支持该机制。

*`mysqlnd_qc.slam_defense_ttl`* 整形
>设置一个过期条目的`TTL`，使得这个条目在被其他用户更新时仍提供服务，[APC](http://www.php.net/ref.apc)存储处理器支持该机制。

*`mysqlnd_qc.collect_normalized_query_trace`* 整形
>收集汇总的标准化的查询跟踪? 默认设置对该选项没有影响。你可以使用定义`NORM_QUERY_TRACE_LOG`编译扩展从而使其生效。

*`mysqlnd_qc.std_data_copy`* 整形
>默认的存储处理器：拷贝缓存有线数据？实验-使用默认设置。

*`mysqlnd_qc.apc_prefix`* 字符串
>[APC](http://www.php.net/ref.apc)存储处理器将数据存储在`APC`用户缓存中。该选项设置了一个用户缓存条目的前缀。

*`mysqlnd_qc.memc_server`* 字符串
>`MEMCACHE`存储处理器: memcache 服务器主机.

*`mysqlnd_qc.memc_port`* 整形
>`MEMCACHE`存储处理器: memcached 服务器主机

*`mysqlnd_qc.sqlite_data_file`* 字符串
>`sqlite`存储处理器:数据文件.除了`:memory:`其他设置可能没有实际价值。

#### 22.9.7.6. 预定义常量 ####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

以下常量由此扩展定义，而且只当扩展被编译到PHP中，或者在运行时动态加载时有效。

*SQL相关提示*

**Example 22.322. Using SQL hint constants**

查询缓存由SQL提示控制，SQL提示用来启用和禁用缓存，也可以使用SQL提示设置查询的`TTL`。

SQL提示控制的查询缓存可以在编译时刻手动更改。这使得在已经采用SQL提示并且被其他系统解析过的环境中，也可以使用`mysqlnd_qc`。因此，建议使用SQL提示字符串常量而不是在查询字符串上手动添加默认的SQL提示。

```php
<?php
/* Use constants for maximum portability */
$query = "/*" . MYSQLND_QC_ENABLE_SWITCH . "*/SELECT id FROM test";

/* Valid but less portable: default TTL */
$query = "/*qc=on*/SELECT id FROM test";

/* Valid but less portable: per statement TTL */
$query = "/*qc=on*//*qc_ttl=5*/SELECT id FROM test";

printf("MYSQLND_QC_ENABLE_SWITCH: %s\n", MYSQLND_QC_ENABLE_SWITCH);
printf("MYSQLND_QC_DISABLE_SWITCH: %s\n", MYSQLND_QC_DISABLE_SWITCH);
printf("MYSQLND_QC_TTL_SWITCH: %s\n", MYSQLND_QC_TTL_SWITCH);
?>
```

以上示例将输出:

```
MYSQLND_QC_ENABLE_SWITCH: qc=on
MYSQLND_QC_DISABLE_SWITCH: qc=off
MYSQLND_QC_TTL_SWITCH: qc_ttl=
```

*`MYSQLND_QC_ENABLE_SWITCH`* (字符串)
> SQL提示，启用缓存查询。

*`MYSQLND_QC_DISABLE_SWITCH`* (字符串)
> SQL提示，如果 mysqlnd_qc.cache_by_default = 1. 禁用缓存查询。

*`MYSQLND_QC_TTL_SWITCH`* (字符串)
> SQL提示，设置结果集的TTL。

*`MYSQLND_QC_SERVER_ID_SWITCH`* (字符串)
> 一般情况下，不实用这个SQL提示.
> 当[PECL/mysqlnd\_ms](http://dev.mysql.com/doc/refman/5.6/en/apis-php-book.mysqlnd-ms.html)需要将源自不同物理连接的一个语句的缓存条目分组汇集时，才使用到这个提示。如果这个提示用于连接设置，比如说用户，那么主机名以及字符集将不考虑产生查询的缓存键。相反的，给定的值和查询字符串将用作散列函数输入，然后产生一个健。
> 
> 如果得到指示，PECL/mysqlnd\_ms可能从MySQL Replication slaves缓存结果。因为它可以保持很多到slave的连接，缓存键也不应该由用户、主机名以及其他可能针对不同slave连接而变化的配置生成。相反，PECL/mysqlnd\_ms提供一个标识符，它指的是slave连接组，这个组将被允许共享缓存条目，无论是哪个物理连接产生的。
> 
> 不建议在PECL / mysqlnd_ms以外使用该功能。

[*mysqlnd_qc_set_cache_condition*](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-cache-condition) 相关讲述

**Example 22.323. Example [mysqlnd_qc_set_cache_condition](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-cache-condition) usage**

对于那些不以SQL提示开头而需要手动启用缓存的的语句，函数[mysqlnd_qc_set_cache_condition](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-cache-condition)允许对这些语句自动缓存设置条件。

```php
<?php
/* Cache all accesses to tables with the name "new%" in schema/database "db_example" for 1 second */
if (!mysqlnd_qc_set_cache_condition(MYSQLND_QC_CONDITION_META_SCHEMA_PATTERN, "db_example.new%", 1)) {
  die("Failed to set cache condition!");
}

$mysqli = new mysqli("host", "user", "password", "db_example", "port");
/* cached although no SQL hint given  */
$mysqli->query("SELECT id, title FROM news");

$pdo_mysql = new PDO("mysql:host=host;dbname=db_example;port=port", "user", "password");
/* not cached: no SQL hint, no pattern match */
$pdo_mysql->query("SELECT id, title FROM latest_news");
/* cached: TTL 1 second, pattern match */
$pdo_mysql->query("SELECT id, title FROM news");
?>
```

*`MYSQLND_QC_CONDITION_META_SCHEMA_PATTERN`* (整形)
> 作为[mysqlnd_qc_set_cache_condition](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-cache-condition)的一个参数，设置基于模式的自动缓存条件。

*其他*

可以通过以下方式获得该插件的版本号， `MYSQLND_QC_VERSION`这是数字版本号的字符串表示；或者 `MYSQLND_QC_VERSION_ID`是一个整数，例如10000。卡发人员可以通过如下方式计算版本号。

<table summary="Unknown PHP API feature." border="1" style="border-collapse:collapse">
  <colgroup>
  <col>
  <col>
  </colgroup>
  <thead>
    <tr>
      <th scope="col">Version (part)</th>
      <th scope="col">Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row">Major*10000</td>
      <td>1*10000 = 10000</td>
    </tr>
    <tr>
      <td scope="row">Minor*100</td>
      <td>0*100 = 0</td>
    </tr>
    <tr>
      <td scope="row">Patch</td>
      <td>0 = 0</td>
    </tr>
    <tr>
      <td scope="row">MYSQLND_QC_VERSION_ID</td>
      <td>10000</td>
    </tr>
  </tbody>
</table>

*`MYSQLND_QC_VERSION`* (字符串)
>插件版本字符串，例如 “1.0.0-prototype”.

*`MYSQLND_QC_VERSION_ID`* (整形)
>插件版本号，例如, 10000.

#### 22.9.7.7. mysqlnd_qc 函数 ####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

##### 22.9.7.7.1. mysqlnd_qc_clear_cache #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- mysqlnd_qc_clear_cache

> 刷新所有缓存内容

***描述***

`bool mysqlnd_qc_clear_cache();`

刷新所有缓存内容.

刷新缓存的存储处理器的一个职责，除`memcache`存储处理器外，所有内置的存储处理器都支持刷新缓存。`Memcache`存储处理器不能刷新其缓存内容。.

用户定义的存储处理器可能支持也可能不支持这个操作。.

***参数***

此函数无参数。.

***返回值***

成功返回`TRUE`，失败则返回`FALSE`。

如果返回值是FALSE的话，则表明刷新所有缓存内容失败或者当前活跃的存储处理器不支持这个操作。应用程序不能指望调用这个函数总会刷新成功。
##### 22.9.7.7.2. mysqlnd_qc_get_available_handlers #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- mysqlnd_qc_get_available_handlers

>返回可用存储处理程器的列表

***描述***

`array mysqlnd_qc_get_available_handlers();`

哪个存储处理器可用取决于查询缓存插件的编译时配置。默认的存储处理器通常情况下都可用。其他的则必须在构建扩展时显示启用。

***参数***

此函数无参数

***返回值***

返回一个可用的内置存储处理器的数组，并且给出了每个存储处理器的版本号以及版本字符串。

**Example 22.324. mysqlnd_qc_get_available_handlers example**

```php
<?php
var_dump(mysqlnd_qc_get_available_handlers());
?>
```
   
输出:

```
array(5) {
  ["default"]=>
  array(2) {
    ["version"]=>
    string(5) "1.0.0"
    ["version_number"]=>
    int(100000)
  }
  ["user"]=>
  array(2) {
    ["version"]=>
    string(5) "1.0.0"
    ["version_number"]=>
    int(100000)
  }
  ["APC"]=>
  array(2) {
    ["version"]=>
    string(5) "1.0.0"
    ["version_number"]=>
    int(100000)
  }
  ["MEMCACHE"]=>
  array(2) {
    ["version"]=>
    string(5) "1.0.0"
    ["version_number"]=>
    int(100000)
  }
  ["sqlite"]=>
  array(2) {
    ["version"]=>
    string(5) "1.0.0"
    ["version_number"]=>
    int(100000)
  }
}
```

***See Also***

[Installation](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.installation)

[mysqlnd_qc_set_storage_handler](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-storage-handler)

##### 22.9.7.7.3. mysqlnd_qc_get_cache_info #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)


- `mysqlnd_qc_get_cache_info`

>返回处理器上的信息，缓存条目的数量和缓存条目，如果可行的话

***描述***

`array mysqlnd_qc_get_cache_info();`

***参数***

此函数无参数

***返回值***

返回处理器上的信息，缓存条目的数量和缓存条目，如果可行的话。对于缓存条目，数据是否被返回，以及会返回什么样的数据，是受当前活跃的存储处理器支配的。Storage handler are free to return any data。建议存储处理器至少返回默认处理器支持的数据，如果技术上可行的话。

信息的范围的PHP进程。根据PHP部署模型，一个进程能够服务一个或多个web请求。

对于所有的缓冲活动，数据是基于每个处理器被汇总起来的。要辨别有多少查询源自于`mysqli`, `PDO_MySQL` 或者`mysql`是不可能的。API调用对于分类汇总数据值做出不少帮助。用[mysqlnd_qc_get_core_stats](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-core-stats)获得所有存储处理器的时间数据汇总。

缓存数组的信息

*`handler` 字符串*
当前活跃的存储处理器.

所有的存储处理器. 自1.0.0.

*`handler_version` 字符串*

活跃的存储处理器的版本.

所有的存储处理器. 自1.0.0.

*`num_entries` 整形*
缓存条目的数量 数值取决于使用的存储处理器。

默认情况下，APC和SQLite存储处理器提供缓存条目的实际数目。 

MEMCACHE返回值总为0，MEMCACHE不支持计算缓存条目的数目。

如果使用一个用户定义的存储处理器，则会报告数据属性。

自1.0.0.

*`data` 数组*

活跃的存储处理器的版本。

额外的存储处理器缓存条目的相关数据。 存储处理器需要提供相似的和可比较的信息。A user defined storage handler is free to return any data。

自1.0.0.

下面的信息是默认存储处理器提供的数据属性信息。

数据属性持有一个hash，这个hash是以存储处理器的内部缓存条目标识符为索引。缓存条目的标识符是人可阅读的，而且它包含通向缓存条目的查询字符串。请参阅下面的例子。每个缓存条目都包含下面的数据。

*`statistics` array*

缓存条目的统计数据.

自1.0.0.
<table summary="Unknown PHP API feature." border="1">
	<colgroup>
		<col>
		<col>
		<col>
	</colgroup>
	<thead>
		<tr>
			<th scope="col">属性</th><th scope="col">描述</th><th scope="col">版本</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row"><code class="literal">
				rows</code></td><td>缓存结果集的行数。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				stored_size</code></td><td>缓存结果集的大小（以字节为单位）。是有效载荷的大小。该值是不适合用于计算包括缓存条目管理开销在内的缓存条目总内存消耗。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				cache_hits</code></td><td>返回缓存条目的频率。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				run_time</code></td><td>缓存条目所属语句的运行时间。是未缓存的语句的运行时间。时间是从发送给MySQL一个语句到从MySQL接收到一个回复。使用查询缓存插件而存储的运行时间可以这样计算：缓存条目所属语句的运行时间。是未缓存的语句的运行时间。时间是从发送给MySQL一个语句到从MySQL接收到一个回复。使用查询缓存插件而存储的运行时间可以这样计算：<code class="literal">cache_hits * ((run_time - avg_run_time)</code> + <code class="literal">(store_time - avg_store_time))</code>。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				store_time</code></td><td>缓存条目所属语句结果集的存储时间。是读取以及存储未缓存语句结果的时间。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				min_run_time</code></td><td>缓存语句的最低运行时间。是在缓存中找到语句所用的时间。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				min_store_time</code></td><td>缓存语句的最小存储时间。是从存储介质上获取缓存结果以及解码所花费的时间。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				avg_run_time</code></td><td>缓存语句的平均运行时间。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				avg_store_time</code></td><td>缓存语句的平均存储时间。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				max_run_time</code></td><td>缓存语句的最大运行时间。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				max_store_time</code></td><td>缓存语句的最大存储时间。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				valid_until</code></td><td>缓存条目失效时间戳。</td><td>自1.1.0.</td>
		</tr>
	</tbody>
</table>

*`metadata` array*

元数据的缓存条目，是由MySQL与关注的语句的结果集共同提供的。不同版本的MySQL服务器将返回不同的元数据。不像一些PHP MySQL扩展，他们没有尝试隐藏调用方MySQL服务器版本依赖以及版本细节。请参阅所属MySQL服务器MySQL C API文档进行进一步的细节了解。
 
缘数据列表每一列都包含一个条目。

自1.0.0.

<table summary="Unknown PHP API feature." border="1">
	<colgroup>
		<col>
		<col>
		<col>
	</colgroup>
	<thead>
		<tr>
			<th scope="col">属性</th><th scope="col">描述</th><th scope="col">版本</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row"><code class="literal">
				name</code></td><td>字段名称。根据MySQL版本的不同，字段名称可能是别名。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				org_name</code></td><td>字段名称。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				table</code></td><td>表名。如果在表中使用了别名，那它通常是别名。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				org_table</code></td><td>表名。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				db</code></td><td>数据库/模式名称。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				max_length</code></td><td>该字段的最大宽度。根据MySQL版本不用，细节可能有所不同。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				length</code></td><td>该字段的宽度。根据MySQL版本不用，细节可能有所不同。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				type</code></td><td>C API类型常量值。建议使用<code class="literal">mysqli</code>扩展提供以测试其含义的类型常量。你不应该用与具体数字比较的方式测试具体的类型值。</td><td>自1.0.0.</td>
		</tr>
	</tbody>
</table>

APC存储处理器返回除元数据以外相同的信息。一个缓存条目的元数据被设置为NULL。

MEMCACHE 存储处理器并不填充数据属性。在MEMCACHE存储处理器上，基于每个缓存条目的统计信息是不可用的。

A user defined storage handler is free to provide any data.

***示例***

**Example 22.325. mysqlnd_qc_get_cache_info example**

The example shows the output from the built-in default storage handler. Other storage handler may report different data.

```php
<?php
/* Populate the cache, e.g. using mysqli */
$mysqli = new mysqli("host", "user", "password", "schema");
$mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/SELECT id FROM test");

/* Display cache information */
var_dump(mysqlnd_qc_get_cache_info());
?>
```
   
输出：

```
array(4) {
 ["num_entries"]=>
 int(1)
 ["handler"]=>
 string(7) "default"
 ["handler_version"]=>
 string(5) "1.0.0"
 ["data"]=>
 array(1) {
   ["Localhost via UNIX socket 3306 user schema|/*qc=on*/SELECT id FROM test"]=>
   array(2) {
     ["statistics"]=>
     array(11) {
       ["rows"]=>
       int(6)
       ["stored_size"]=>
       int(101)
       ["cache_hits"]=>
       int(0)
       ["run_time"]=>
       int(471)
       ["store_time"]=>
       int(27)
       ["min_run_time"]=>
       int(0)
       ["max_run_time"]=>
       int(0)
       ["min_store_time"]=>
       int(0)
       ["max_store_time"]=>
       int(0)
       ["avg_run_time"]=>
       int(0)
       ["avg_store_time"]=>
       int(0)
     }
     ["metadata"]=>
     array(1) {
       [0]=>
       array(8) {
         ["name"]=>
         string(2) "id"
         ["orig_name"]=>
         string(2) "id"
         ["table"]=>
         string(4) "test"
         ["orig_table"]=>
         string(4) "test"
         ["db"]=>
         string(4) "schema"
         ["max_length"]=>
         int(1)
         ["length"]=>
         int(11)
         ["type"]=>
         int(3)
       }
     }
   }
 }
}
```

***See Also***

[mysqlnd_qc_get_core_stats](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-core-stats)

##### 22.9.7.7.4. mysqlnd_qc_get_core_stats #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- `mysqlnd_qc_get_core_stats`

查询缓存核心收集的统计数据

***描述***
`array mysqlnd_qc_get_core_stats();`

返回一个有缓存插件核心收集的统计信息的数组，对于每个存储处理器，会报告相同的数据字段，因为数据是由核心收集的。

`PHP`设置`mysqlnd_qc.collect_statistics`会控制统计数据的的收集。 出于性能方面的考虑，在默认情况下是禁用的统计信息的收集的。 禁用的统计信息的收集同时也会禁用相关时间统计信息的收集。

`PHP`配置设置`mysqlnd_qc.collect_time_statistics`会控制时间相关统计数据的收集。

核心统计信息的范围是`PHP`进程。根据您的部署模型，一个`PHP`进程可能会处理一个或多个请求。

所有的缓存条目和所有的存储处理器，统计信息都将会被汇总。但是要分辨有多少条查询源自于`mysqli`, `PDO_MySQL`或`mysql`是不可能的。API调用会帮助完成数据值的汇总。

***参数***

此函数无参数。

***返回值***

核心统计数组

<table summary="Unknown PHP API feature." border="1">
	<colgroup>
		<col width="10%">
		<col width="70%">
		<col width="20%">
	</colgroup>
	<thead>
		<tr>
			<th scope="col">统计信息</th><th scope="col">统计信息</th><th scope="col">版本</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row">
			<code class="literal">
				cache_hit
			</code></td><td>语句被认为是可缓存的，被缓存的数据得到了重用。语句被认为可缓存，若发生一次缓存失效，但是语句在我们处理时被其他人缓存，因此，我们能后从刷新的缓存中得到结果。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				cache_miss
			</code></td><td>语句被认为是可缓存的。• 并且已被添加到缓存。• 但是PHP配置指令mysqlnd_qc.cache_no_table = 1 阻止缓存。• 但是需要一个未被缓冲的结果。• 但是一个缓冲的结果集为空。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				cache_put
			</code></td><td>语句被认为是可缓存的并且已被添加到缓存。计算派生统计信息时要小心，如果另一个进程已经填充了这个缓存，那么一个存储生存周期在一个进程之外的存储处理器可能报告 cache_put = 0 和cache_hit > 0。你也许想要从mysqlnd_qc_get_cache_info使用num_entries，如果处理器支持的话（默认，APC）。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_should_cache
			</code></td><td>语句在基于查询字符串分析的基础上被认为是可缓存的。语句可能被添加到缓存中，也可能不被添加到缓存中。请参考cache_put。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_should_not_cache
			</code></td><td>语句在基于查询字符串分析的基础上被认为是不可缓存的。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_not_cached
			</code></td><td>语句被认为是不可缓存的，或者认为可缓存但是存储处理器没有给它返回一个hash健。。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_could_cache
			</code></td><td>语句被认为是可缓存的...• ... 并且语句运行无错误• ... 并且元数据在结果集中至少显示一列语句可能已经在缓存中或者没在缓存中。可能稍后被添加到缓存中或者不被添加。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_found_in_cache
			</code></td><td>语句被认为是可缓存的，并且在缓存中也找到了它，但是我们还没有回放缓存数据也没有发送结果集到客户端。这并不被认为是一个缓存命中，因为客户端可能并没有获取到结果，或者缓存数据可能不正确。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_uncached_other
			</code></td><td>语句被认为是可缓存的，而且它可能已经在缓存中或者没在缓存中。但是或者回放缓存数据失败了，没有可用的结果集，或者是发生了其他的错误。</td><td class="auto-generated">&nbsp;</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_uncached_no_table
			</code></td><td> 语句还没有被缓存，因为在结果集中，元数据至少有一列没有表名。举一个类似这样查询的例子SELECT SLEEP(1). 要缓存那些语句，你必须更改PHP配置指令mysqlnd_qc.cache_no_table 的默认值。将其设置为1：mysqlnd_qc.cache_no_table = 1.. 通常，并不希望缓存这样的语句。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_uncached_use_result
			</code></td><td>如果使用了一缓冲的结果集，那么语句应该是被缓存的。这种情况也被认为是缓存失效，而且缓存失效也会增加。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_aggr_run_time_cache_hit
			</code></td><td>所有缓存查询的聚合时间（ms）。缓存查询是使cache_hit增加的那些查询。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_aggr_run_time_cache_put
			</code></td><td所有未被缓存查询的聚合时间（ms），这些查询已经被放入缓存。另见cache_put。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_aggr_run_time_total
			</code></td><td>所有未缓存查询的聚合时间（ms），查询查询已经经过检查并且已经经过查询缓存的执行。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_aggr_store_time_cache_hit
			</code></td><td>所有缓存查询的聚合存储时间（ms），缓存的查询是使cache_hit增加的那些查询。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_aggr_store_time_cache_put
			</code></td><td>所有未被缓存查询的聚合存储时间（ms），这些查询都已经被放入缓存。另见cache_put。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				query_aggr_store_time_total
			</code></td><td>所有未被缓存和已被缓存的查询的聚合存储时间（ms），这些查询已经经过检查并且已经被查询缓存执行。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				receive_bytes_recorded
			</code></td><td>从MySQL发送至PHP的被记录的传入的网络流量（字节）。流量可能被添加到缓存中也可能没被添加。流量是针对所有查询的，无论其是否被缓存。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				receive_bytes_replayed
			</code></td><td>缓存期间重放的网络流量。这个流量是所有保存的传入流量的总和，因为使用的是查询缓存插件。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				send_bytes_recorded
			</code></td><td>从MySQL发送至PHP的被记录的传出的网络流量（字节）。流量可能被添加到缓存中也可能没被添加。流量是针对所有查询的，无论其是否被缓存。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				send_bytes_replayed
			</code></td><td>缓存期间重放的网络流量。这个流量是所有保存的传出流量的总和，因为使用的是查询缓存插件。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				slam_stale_refresh
			</code></td><td>缓存失效的数量，缓存失效是因为被触发使用陈旧的数据，直到引发这个缓存失效的客户端刷新这个缓存条目。</td><td>自1.0.0.</td>
		</tr>
		<tr>
			<td scope="row">
			<code class="literal">
				slam_stale_hit
			</code></td><td>缓存命中的数量，当一个陈旧的缓存条目被刷新时。</td><td>自1.0.0.</td>
		</tr>
	</tbody>
</table>

***示例***

**Example 22.326. mysqlnd_qc_get_core_stats example**

```php
<?php
/* Enable collection of statistics - default: disabled */
ini_set("mysqlnd_qc.collect_statistics", 1);

/* Enable collection of all timing related statistics -
default: enabled but overruled by mysqlnd_qc.collect_statistics = 0 */
ini_set("mysqlnd_qc.collect_time_statistics", 1);

/* Populate the cache, e.g. using mysqli */
$mysqli = new mysqli('host', 'user', 'password', 'schema');

/* Cache miss and cache put */
$mysqli->query("/*qc=on*/SELECT id FROM test");
/* Cache hit */
$mysqli->query("/*qc=on*/SELECT id FROM test");

/* Display core statistics */
var_dump(mysqlnd_qc_get_core_stats());
?>
```
   
以上示例将输出：

```
array(26) {
  ["cache_hit"]=>
  string(1) "1"
  ["cache_miss"]=>
  string(1) "1"
  ["cache_put"]=>
  string(1) "1"
  ["query_should_cache"]=>
  string(1) "2"
  ["query_should_not_cache"]=>
  string(1) "0"
  ["query_not_cached"]=>
  string(1) "0"
  ["query_could_cache"]=>
  string(1) "2"
  ["query_found_in_cache"]=>
  string(1) "1"
  ["query_uncached_other"]=>
  string(1) "0"
  ["query_uncached_no_table"]=>
  string(1) "0"
  ["query_uncached_no_result"]=>
  string(1) "0"
  ["query_uncached_use_result"]=>
  string(1) "0"
  ["query_aggr_run_time_cache_hit"]=>
  string(1) "4"
  ["query_aggr_run_time_cache_put"]=>
  string(3) "395"
  ["query_aggr_run_time_total"]=>
  string(3) "399"
  ["query_aggr_store_time_cache_hit"]=>
  string(1) "2"
  ["query_aggr_store_time_cache_put"]=>
  string(1) "8"
  ["query_aggr_store_time_total"]=>
  string(2) "10"
  ["receive_bytes_recorded"]=>
  string(2) "65"
  ["receive_bytes_replayed"]=>
  string(2) "65"
  ["send_bytes_recorded"]=>
  string(2) "29"
  ["send_bytes_replayed"]=>
  string(2) "29"
  ["slam_stale_refresh"]=>
  string(1) "0"
  ["slam_stale_hit"]=>
  string(1) "0"
  ["request_counter"]=>
  int(1)
  ["process_hash"]=>
  int(3547549858)
}
```

***See Also***

[Runtime configuration](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)

[mysqlnd_qc.collect_statistics](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-statistics)

[mysqlnd_qc.time_statistics](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.time-statistics)

[mysqlnd_qc_get_cache_info](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-cache-info)


##### 22.9.7.7.5. mysqlnd_qc_get_normalized_query_trace_log #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- `mysqlnd_qc_get_normalized_query_trace_log`

为每一个经过查询缓存检查的查询返回一个标准化的查询跟踪日志。

***描述***

`array mysqlnd_qc_get_normalized_query_trace_log();`

为每一个经过查询缓存检查的查询返回一个标准化的查询跟踪日志。跟踪日志的收集在默认情况下是禁止的。如果要收集跟踪日志，那么你必须设置PHP配置指令`mysqlnd_qc.collect_normalized_query_trac`为 1。

跟踪日志中的条目是根据标准化查询语句分组的。标准化查询语句是那种所有的语句参数值都被替换成一个问号，例如`SELECT id FROM test WHERE id = 1`和`SELECT id FROM test WHERE id = 2`两个语句被标准化为`SELECT id FROM test WHERE id = ?`无论何时一个语句被查询缓存检测且匹配标准化语句的模式，其统计信息都将以标准化语句字符串分组。

***参数***

此函数无返回值。

***返回值***

一个查询日志的数组。每个列表条目都包含标准化查询字符串以及更加详细的信息。

<table summary="Unknown PHP API feature." border="1">
  <colgroup>
    <col>
    <col>
  </colgroup>
  <thead>
    <tr>
      <th scope="col">健</th><th scope="col">描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td scope="row"><code class="literal">
        query</code></td><td>标准化语句字符串。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        occurences</code></td><td>除了创建日至条目的那个语句外，有多少语句匹配标准化语句字符串。如果一个语句已经是标准化的，那么值为零，其标准化表示已被添加到日志中，但是PECL / mysqlnd_qc检查的进一步查询具有相同的标准化语句字符串。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        eligible_for_caching</code></td><td>语句是否可被缓存。一个有缓存资格的语句不一定已经缓存。想要确切的说出缓存的语句是否对造就汇总标准化语句日志条目或者有多少语句对其造就是不可能的。但是，可以根据最小运行时间和平均运行时间对其做一个经验性的猜测。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        avg_run_time</code></td><td>所有造就查询日至条目的查询的平均运行时间。时间是从发送查询语句至MySQL开始，到接收到来自MySQL的一个应答。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        avg_store_time</code></td><td>所有造就查询日至条目的查询的平均存储时间。所需要的时间是从服务器获取一个语句结果集，发至客户端，然后在存储在客户端。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        min_run_time</code></td><td>所有造就查询日至条目的查询的最小运行时间。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        min_store_time</code></td><td>所有造就查询日至条目的查询的最小存储时间。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        max_run_time</code></td><td>所有造就查询日至条目的查询的最大运行时间。</td>
    </tr>
    <tr>
      <td scope="row"><code class="literal">
        max_store_time</code></td><td>所有造就查询日至条目的查询的最大存储时间。</td>
    </tr>
  </tbody>
</table>

***示例***

**Example 22.327. mysqlnd_qc_get_normalized_query_trace_log example**

```php
mysqlnd_qc.collect_normalized_query_trace=1


<?php
/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* not cached */
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* cache put */
$res = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 2");
var_dump($res->fetch_assoc());
$res->free();

/* cache hit */
$res = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 2");
var_dump($res->fetch_assoc());
$res->free();

var_dump(mysqlnd_qc_get_normalized_query_trace_log());
?>
```
   
输出：

```
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "2"
}
array(1) {
  ["id"]=>
  string(1) "2"
}
array(4) {
  [0]=>
  array(9) {
    ["query"]=>
    string(25) "DROP TABLE IF EXISTS test"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [1]=>
  array(9) {
    ["query"]=>
    string(27) "CREATE TABLE test (id INT )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [2]=>
  array(9) {
    ["query"]=>
    string(40) "INSERT INTO test (id ) VALUES (? ), (? )"
    ["occurences"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["avg_run_time"]=>
    int(0)
    ["min_run_time"]=>
    int(0)
    ["max_run_time"]=>
    int(0)
    ["avg_store_time"]=>
    int(0)
    ["min_store_time"]=>
    int(0)
    ["max_store_time"]=>
    int(0)
  }
  [3]=>
  array(9) {
    ["query"]=>
    string(31) "SELECT id FROM test WHERE id =?"
    ["occurences"]=>
    int(2)
    ["eligible_for_caching"]=>
    bool(true)
    ["avg_run_time"]=>
    int(159)
    ["min_run_time"]=>
    int(12)
    ["max_run_time"]=>
    int(307)
    ["avg_store_time"]=>
    int(10)
    ["min_store_time"]=>
    int(8)
    ["max_store_time"]=>
    int(13)
  }
}
```
***See Also***

[Runtime configuration](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)

[mysqlnd_qc.collect_normalized_query_trace](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-query-trace)

[mysqlnd_qc.time_statistics](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.time-statistics)

[mysqlnd_qc_get_query_trace_log](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-query-trace-log)


##### 22.9.7.7.6. mysqlnd_qc_get_query_trace_log #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- `mysqlnd_qc_get_query_trace_log`

为每个经过查询缓存检查过的查询返回一个回溯

***描述***

`array mysqlnd_qc_get_query_trace_log();`

为每个经过查询缓存检查过的查询返回一个回溯. 默认情况下，回溯的收集是禁止的。要收集回溯，应该设置PHP配置指令`mysqlnd_qc.collect_query_trace`为`1`。

指令`mysqlnd_qc.query_trace_bt_depth`限制回溯的最大深度。

***参数***

此函数无参数

***返回值***

查询回溯的数组。每个列表标目都包含其查询字符串，回溯以及详细信息。

<table summary="Unknown PHP API feature." border="1">
	<colgroup>
		<col>
		<col>
	</colgroup>
	<thead>
		<tr>
			<th scope="col">键</th><th scope="col">描述</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td scope="row"><code class="literal">
				query</code></td><td>查询字符串。</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				origin</code></td><td>代码回溯。</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				run_time</code></td><td>查询的运行时间（以毫秒为单位）。设置PHP配置指令 mysqlnd_qc.time_statistics为0可以禁用对所有时间的收集以及必要的gettimeofday系统调用。</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				store_time</code></td><td>查询结果集的存储时间（以毫秒为单位）。设置PHP配置指令mysqlnd_qc.time_statistics为0可以禁用对所有时间的收集以及必要的gettimeofday系统调用。</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				eligible_for_caching</code></td><td>如果查询可缓存，返回TRUE，否则返回FALSE。</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				no_table</code></td><td>如果查询产生了一个结果集，并且结果集中至少有一列在其元数据里没有设置表名，则返回TRUE。通常的情况是，查询可能不想缓存类似SELECT SLEEP(1)。默认情况下，这样的查询不会添加到缓存中。另见PHP配置指令<code class="literal">
				mysqlnd_qc.cache_no_table</code>。</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				was_added</code></td><td>如果查询结果被放入到缓存，则返回TRUE、否则返回FALSE。</td>
		</tr>
		<tr>
			<td scope="row"><code class="literal">
				was_already_in_cache</code></td><td>果查询结果应该已经被放入缓存但是还没在缓存中(cache hit)，则返回TRUE、否则返回FALSE。</td>
		</tr>
	</tbody>
</table>

***Examples***

**Example 22.328. mysqlnd_qc_get_query_trace_log example**

```php
mysqlnd_qc.collect_query_trace=1


<?php
/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema", "port", "socket");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2)");

/* not cached */
$res = $mysqli->query("SELECT id FROM test WHERE id = 1");
var_dump($res->fetch_assoc());
$res->free();

/* cache put */
$res = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 2");
var_dump($res->fetch_assoc());
$res->free();

/* cache hit */
$res = $mysqli->query("/*" . MYSQLND_QC_ENABLE_SWITCH . "*/" . "SELECT id FROM test WHERE id = 2");
var_dump($res->fetch_assoc());
$res->free();

var_dump(mysqlnd_qc_get_query_trace_log());
?>
```
   
输出：

```
array(1) {
  ["id"]=>
  string(1) "1"
}
array(1) {
  ["id"]=>
  string(1) "2"
}
array(1) {
  ["id"]=>
  string(1) "2"
}
array(6) {
  [0]=>
  array(8) {
    ["query"]=>
    string(25) "DROP TABLE IF EXISTS test"
    ["origin"]=>
    string(102) "#0 qc.php(4): mysqli->query('DROP TABLE IF E...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [1]=>
  array(8) {
    ["query"]=>
    string(25) "CREATE TABLE test(id INT)"
    ["origin"]=>
    string(102) "#0 qc.php(5): mysqli->query('CREATE TABLE te...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [2]=>
  array(8) {
    ["query"]=>
    string(36) "INSERT INTO test(id) VALUES (1), (2)"
    ["origin"]=>
    string(102) "#0 qc.php(6): mysqli->query('INSERT INTO tes...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(0)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [3]=>
  array(8) {
    ["query"]=>
    string(32) "SELECT id FROM test WHERE id = 1"
    ["origin"]=>
    string(102) "#0 qc.php(9): mysqli->query('SELECT id FROM ...')
#1 {main}"
    ["run_time"]=>
    int(0)
    ["store_time"]=>
    int(25)
    ["eligible_for_caching"]=>
    bool(false)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [4]=>
  array(8) {
    ["query"]=>
    string(41) "/*qc=on*/SELECT id FROM test WHERE id = 2"
    ["origin"]=>
    string(103) "#0 qc.php(14): mysqli->query('/*qc=on*/SELECT...')
#1 {main}"
    ["run_time"]=>
    int(311)
    ["store_time"]=>
    int(13)
    ["eligible_for_caching"]=>
    bool(true)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(true)
    ["was_already_in_cache"]=>
    bool(false)
  }
  [5]=>
  array(8) {
    ["query"]=>
    string(41) "/*qc=on*/SELECT id FROM test WHERE id = 2"
    ["origin"]=>
    string(103) "#0 qc.php(19): mysqli->query('/*qc=on*/SELECT...')
#1 {main}"
    ["run_time"]=>
    int(13)
    ["store_time"]=>
    int(8)
    ["eligible_for_caching"]=>
    bool(true)
    ["no_table"]=>
    bool(false)
    ["was_added"]=>
    bool(false)
    ["was_already_in_cache"]=>
    bool(true)
  }
}
```

***See Also***


[Runtime configuration](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)

[mysqlnd_qc.collect_query_trace](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-query-trace)

[mysqlnd_qc.query_trace_bt_depth](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.query-trace-bt-depth)

[mysqlnd_qc.time_statistics](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.time-statistics)

[mysqlnd_qc.cache_no_table](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.cache-no-table)

[mysqlnd_qc_get_normalized_query_trace_log](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-normalized-query-trace-log)


##### 22.9.7.7.7. mysqlnd_qc_set_cache_condition #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- `mysqlnd_qc_set_cache_condition`

为自动缓存设置条件

***描述***

`bool mysqlnd_qc_set_cache_condition(int condition_type,
                                    mixed condition,
                                    mixed condition_option);`

为自动缓存设置条件，这些语句没有用来启用缓存的SQL提示。

***参数***

`condition_type`

条件的类型，唯一可用的值 `MYSQLND_QC_CONDITION_META_SCHEMA_PATTERN`。

`condition`

同`condition_type`一同设置条件。参数的类型以及结果取决于`condition_type`。

如果`condition_type`值为`MYSQLND_QC_CONDITION_META_SCHEMA_PATTERN`，`condition`则必须是字符串。这个字符串设置了一个模式，如果结果集的表以及数据库元数据条目匹配这个模式，则语句将被缓存。模式匹配的检查是根据底层MySQL客户端服务器库提供的db以及`org_table`元数据条目。对于这两个条目，详细信息请参考MySQL参考手册。`db`以及`org_table`的值，在与`condition`相匹配之前，是用点(`.`)连接起来的。模式匹配支持通配符`%`和`_`。通配符`%`匹配一个或多个任意的字符、`_`匹配任意一个字符。反斜线是转义符号。

`condition_option`

`condition`的选项. 类型以及结构依赖于`condition_type`。

如果`condition_type`值为`MYSQLND_QC_CONDITION_META_SCHEMA_PATTERN`，则`condition_options`是TTL。

***示例***

**Example 22.329. mysqlnd_qc_set_cache_condition example**

```php
<?php
/* Cache all accesses to tables with the name "new%" in schema/database "db_example" for 1 second */
if (!mysqlnd_qc_set_cache_condition(MYSQLND_QC_CONDITION_META_SCHEMA_PATTERN, "db_example.new%", 1)) {
  die("Failed to set cache condition!");
}

$mysqli = new mysqli("host", "user", "password", "db_example", "port");
/* cached although no SQL hint given  */
$mysqli->query("SELECT id, title FROM news");

$pdo_mysql = new PDO("mysql:host=host;dbname=db_example;port=port", "user", "password");
/* not cached: no SQL hint, no pattern match */
$pdo_mysql->query("SELECT id, title FROM latest_news");
/* cached: TTL 1 second, pattern match */
$pdo_mysql->query("SELECT id, title FROM news");
?>
```

***返回值***

成功返回TRUE，失败返回FALSE。

***See Also***

[Quickstart: pattern based caching](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.quickstart.html#apis-php-mysqlnd-qc.pattern-based-caching
)

##### 22.9.7.7.8. mysqlnd_qc_set_is_select #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- mysqlnd_qc_set_is_select

安装一个回调，以决定是否缓存一个语句。

***描述***

`mixed mysqlnd_qc_set_is_select(string callback);`

安装一个回调，以决定是否缓存一个语句。

提示PELC/mysqlnd\_qc缓存一个查询有多种方法。默认情况下，如果允许缓存所有语句，或者查询字符串前有一个指定的SQL提示，那么PELC/mysqlnd\_qc会尝试缓存，插件内部调用`is_select()`函数。这个内部函数可以用一个用户定义的回调代替。用户定义的回调有责任决定插件室友尝试缓存一个语句。因为内部函数被回调所替代，回调函数取得了完全控制。回调函数可以忽略`mysqlnd_qc.cache_by_default`设置以及SQL提示。

回调是由插件检查的每个语句调用的。它作为语句字符串的一个参数，如果语句将不被缓存，则回调函数返回`FALSE`。如果插件尝试缓存语句结果集，如果有的话，则返回`TRUE`。设PHP配置指令`mysqlnd_qc.ttl`，如此创建的缓存条目将被赋予一个缺省的TTL。如果使用一个不同的TTL，则回调函数返回一个数值来作为TTL。

内部函数`is_select`是内部缓存存储处理器接口的一部分，因此，一个用户定义的存储处理器也拥有相同的功能。

***参数***

此函数无参数

***返回值***

成功返回TRUE，否则返回FALSE。

***例子***

**Example 22.330. mysqlnd_qc_set_is_select example**

```php
<?php
/* callback which decides if query is cached */
function is_select($query) {
  static $patterns = array(
   /* true - use default from mysqlnd_qc.ttl */
   "@SELECT\s+.*\s+FROM\s+test@ismU" => true,
   /* 3 - use TTL = 3 seconds */
   "@SELECT\s+.*\s+FROM\s+news@ismU" => 3
  );
  /* check if query does match pattern */
  foreach ($patterns as $pattern => $ttl) {
    if (preg_match($pattern, $query)) {
      printf("is_select(%45s): cache\n", $query);
      return $ttl;
    }
  }
  printf("is_select(%45s): do not cache\n", $query);
  return false;
}
mysqlnd_qc_set_is_select("is_select");

/* Connect, create and populate test table */
$mysqli = new mysqli("host", "user", "password", "schema");
$mysqli->query("DROP TABLE IF EXISTS test");
$mysqli->query("CREATE TABLE test(id INT)");
$mysqli->query("INSERT INTO test(id) VALUES (1), (2), (3)");

/* cache put */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* cache hit */
$mysqli->query("SELECT id FROM test WHERE id = 1");
/* cache put */
$mysqli->query("SELECT * FROM test");
?>
```
   
以上示例将输出：

```
is_select(                    DROP TABLE IF EXISTS test): do not cache
is_select(                    CREATE TABLE test(id INT)): do not cache
is_select(    INSERT INTO test(id) VALUES (1), (2), (3)): do not cache
is_select(             SELECT id FROM test WHERE id = 1): cache
is_select(             SELECT id FROM test WHERE id = 1): cache
is_select(                           SELECT * FROM test): cache
```

***See Also***

[Runtime configuration](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.configuration)

[mysqlnd_qc.ttl](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.ttl)

[mysqlnd_qc.cache_by_default](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.cache-by-default)

[mysqlnd_qc_set_user_handlers](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-user-handlers)



##### 22.9.7.7.9. mysqlnd_qc_set_storage_handler #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- mysqlnd_qc_set_storage_handler

更改当前的存储处理器

***描述***

`bool mysqlnd_qc_set_storage_handler(string handler);`

设置查询缓存使用的存储处理器。通过[mysqlnd_qc_get_available_handlers](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-available-handlers)能够获得一个可用存储处理器的列表。哪个存储可用依赖于查询缓存插件编译时配置默认的存储处理器通常是可用的。其他存储处理器必须在构建扩展时显示的激活。

***参数***

handler
处理器可以是字符串类型，表示内建的存储处理器的名字或者是一个`mysqlnd_qc_handler_default`类型的对象。内建的存储处理器的名字有`default`, `APC`, `MEMCACHE,sqlite`。

***返回值***

成功返回`TRUE`，失败返回`FALSE`。

如果更改处理器失败，则会抛出一个致命错误，错误可以被捕获。如果上一个存储处理器已经关闭，但是又没有安装新的存储处理器，那么查询缓存将无法操作。

***例子***

**Example 22.331. mysqlnd_qc_set_storage_handler example**

该例子显示了内建的默认存储处理器的输出。其他的处理器输出可能有所不同。

```php
<?php
var_dump(mysqlnd_qc_set_storage_handler("memcache"));

if (true === mysqlnd_qc_set_storage_handler("default"))
  printf("Default storage handler activated");

/* Catchable fatal error */
var_dump(mysqlnd_qc_set_storage_handler("unknown"));
?>
```
   
以上示例将输出：

```
bool(true)
Default storage handler activated
Catchable fatal error: mysqlnd_qc_set_storage_handler(): Unknown handler 'unknown' in (file) on line (line)
```

***See Also***

[Installation](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-mysqlnd-qc.installation)

[mysqlnd_qc_get_available_handlers](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-available-handlers)

##### 22.9.7.7.10. mysqlnd_qc_set_user_handlers #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

- mysqlnd_qc_set_user_handlers

为用户定义程序存储处理器设置回调函数。

***描述***
<pre>
bool mysqlnd_qc_set_user_handlers(string get_hash,
                                  string find_query_in_cache,
                                  string return_to_cache,
                                  string add_query_to_cache_if_not_exists,
                                  string query_is_select,
                                  string update_query_run_time_stats,
                                  string get_stats,
                                  string clear_cache);
</pre>

为用户定义程序存储处理器设置回调函数。

***参数***

*`get_hash`*
>Name of the user function implementing the storage handler get_hash functionality.

*`find_query_in_cache`*
>Name of the user function implementing the storage handler find_in_cache functionality.

*`return_to_cache`*
>Name of the user function implementing the storage handler return_to_cache functionality.

add_query_to_cache_if_not_exists
>Name of the user function implementing the storage handler add_query_to_cache_if_not_exists functionality.

query_is_select
>Name of the user function implementing the storage handler query_is_select functionality.

update_query_run_time_stats
>Name of the user function implementing the storage handler update_query_run_time_stats functionality.

get_stats
>Name of the user function implementing the storage handler get_stats functionality.

clear_cache
>Name of the user function implementing the storage handler clear_cache functionality.

***Return Values***
成功返回TRUE，失败返回FALSE。

***See Also***

[Procedural user-defined storage handler example](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.quickstart.html#apis-php-mysqlnd-qc.set-user-handlers)

#### 22.9.7.8. 修订记录 ####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

这个修订记录是对进行的改动的高度概括，那些改变可能影响应用程序，并且/或者打破向后兼容性。

另参考原发性版本的`CHANGES`文件，那里有更改的完整列表。

##### 22.9.7.8.1. PECL/mysqlnd_qc 1.2 系列 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

1.2.0 - alpha

- 发行日期： 03/2013
- 主题： PHP 5.5 compatibility

特性变化：

- 为PHP 5.5更新构建 (开发人员: Remi Collet)
- APC存储处理器更新
	- APC 3.1.13-beta的修复构建并植入。
- 引入 MYSQLND_QC_VERSION 和 MYSQLND_QC_VERSION_ID

##### 22.9.7.8.2. PECL/mysqlnd_qc 1.1 系列 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

1.1.0 - stable

- 发行日期： 04/2012
- 主题: PHP 5.4 兼容，基于模式的缓存并且支持mysqlnd_ms。 

1.1.0 - beta

- 发行日期： 04/2012
- 主题: PHP 5.4兼容，基于模式的缓存并且支持mysqlnd_ms。

1.1.0 - alpha

- Release date: 04/2012
- 主题: PHP 5.4兼容，基于模式的缓存并且支持mysqlnd_ms。

特性变化：

- APC存储处理器更新
 - 为APC 3.1.9+修复构建
 - 注意：由于APC自身稳定性的原因，目前不建议使用APC存储处理器。:
- 新的 PHP 配置指令
 - [mysqlnd_qc.collect_statistics_log_file](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.collect-statistics-log-file)。汇总缓存统计信息日志文件，每当PHP进程处理10个请求时，日志就会被写入。
 - [mysqlnd_qc.ignore_sql_comments](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.setup.html#apis-php-ini.mysqlnd-qc.ignore-sql-comments)。控制对于缓存健的哈希生成，是否忽略SQL注释。
- 新的常量以及SQL提示
 - [MYSQLND_QC_SERVER_ID_SWITCH](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.constants.html#apis-php-constant.mysqlnd-qc-server-id)允许将来自于不同物理连接的缓存条目分组。 这是PECL/mysqlnd\_ms必要的。
 - [MYSQLND_QC_CONDITION_META_SCHEMA_PATTERN](http://dev.mysql.com/doc/refman/5.6/en/apis-php-mysqlnd-qc.constants.html#apis-php-constant.mysqlnd-qc-condition-meta-schema-pattern)与[mysqlnd_qc_set_cache_condition](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-cache-condition)一同使用。
- 新的函数[mysqlnd_qc_set_cache_condition](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-set-cache-condition)针对内置的基于模式的缓存。将来可能支持更广泛的条件。
- 通过[mysqlnd_qc_get_cache_info](http://dev.mysql.com/doc/refman/5.6/en/apis-php-ref.mysqlnd-qc.html#apis-php-function.mysqlnd-qc-get-cache-info)报告`valid_until`默认参差错落缓存条目的时间戳。
- 包含缓存条目哈希的字符集数，这应防止提供有错误的结果集。
- API变更：get\_hash\_key 期望"port"之后新的参数"charsetnr" (int) 。
- API 变更: 更改is\_select()签名，从`bool is_select()`到`mixed is_select()`。Mixed可以是 boolean或者是`array(long ttl, string server_id)`。是PECL/mysqlnd\_ms必要的。

其他

- Support acting as a cache backend for [PECL/mysqlnd\_ms](http://dev.mysql.com/doc/refman/5.6/en/apis-php-book.mysqlnd-ms.html) 1.3.0-beta or later to transparently replace MySQL Replication slave reads with cache accesses, if the user explicitly allows.

漏洞修复

- 修复漏洞 #59959 (config.m4, wrong library - 64bit memcached handler builds) (开发人员: Remi Collet)

##### 22.9.7.8.3. PECL/mysqlnd_qc 1.0 系列 #####
[Copyright 1997-2012 the PHP Documentation Group.[3505]](http://dev.mysql.com/doc/refman/5.6/en/apis-php.html#php-api-copyright)

1.0.1-stable

- 发行日期： 12/2010
- 主题: 支持预处理语句

新增对预处理语句的支持以及无缓冲查询

1.0.0-beta

- 发行日期： 07/2010
- 主题: 基于TTL的缓存，与各种存储处理器(Memcache, APC, SQLite, user-defined)
基于透明TTL查询结果寒蝉的首次公开版本。能够灵活的存储缓存结果，支持各种存储介质。


